"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const config_1 = require("./config");
const utils_1 = require("./utils");
const getCompileFunction_1 = require("./getCompileFunction");
const findInputs_1 = require("./findInputs");
const findImports_1 = require("./findImports");
const loadConfig_1 = require("./loadConfig");
const saveOutput_1 = require("./saveOutput");
const imports_fs_1 = require("@resolver-engine/imports-fs");
const imports_1 = require("@resolver-engine/imports");
exports.solcOutputMaxBuffer = 4 * 1024 * 1024;
async function compileProject(configPath) {
    await compileAndSave(await loadConfig_1.loadConfig(configPath));
}
exports.compileProject = compileProject;
async function compileAndSave(input) {
    const config = config_1.inputToConfig(input);
    const output = await compile(config);
    await processOutput(output, config);
}
exports.compileAndSave = compileAndSave;
async function compile(input) {
    return newCompile(config_1.inputToConfig(input));
}
exports.compile = compile;
async function newCompile(config) {
    const resolver = imports_fs_1.ImportsFsEngine().addResolver(
    // Backwards compatibility - change node_modules path
    imports_fs_1.resolvers.BacktrackFsResolver(config.nodeModulesDirectory));
    const sources = await imports_1.gatherSources(findInputs_1.findInputs(config.sourceDirectory), '.', resolver);
    return getCompileFunction_1.getCompileFunction(config)(sources, findImports_1.findImports(sources));
}
async function processOutput(output, config) {
    if (output.errors) {
        console.error(formatErrors(output.errors));
    }
    if (anyNonWarningErrors(output.errors)) {
        throw new Error('Compilation failed');
    }
    else {
        await saveOutput_1.saveOutput(output, config);
    }
}
function anyNonWarningErrors(errors) {
    return errors && !errors.every(utils_1.isWarningMessage);
}
function formatErrors(errors) {
    return errors.map(toFormattedMessage).join('\n');
}
function toFormattedMessage(error) {
    return typeof error === 'string' ? error : error.formattedMessage;
}
